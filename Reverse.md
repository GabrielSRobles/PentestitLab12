# Reverse

We will be looking into the **bin** file found in the repository site. 


## Info gathering

After taking a quick look at the code, we see that the most intersting part is the call to the check_pw function.

We disassemble it and get the following output.

* The first and last 2 instructions are the call convention
* The string is stored in rdi, and saved to [rbp-0x18]
* A counter variable is stored in [rbp+0x4] 
* There is a **for** cycle with (i=0;i<=31;i++)
   * It  enters the for at **+15** jumping to the **i<=31** check
   * When the condition pases it jumps to **+17** 
* Instructions **+20** to **+30** are used to set **edx** to the **ith** character of our input string
* Instructions **+30** to **+85** are used to set **eax** to the expected value, using global variables inside the code.
* From **+88** to **+97** we have a conditional return
   * It compares the **dl** (least significant byte of **edx**) with **al** (likewise with **eax**)
   * if(**$dl** !== **al**) return **false** (0x0)
* If the **for** concludes properly, returns **true** (0x1)

```
0x0000000000000a60 <+0>:	push   rbp                       
0x0000000000000a61 <+1>:	mov    rbp,rsp                 
0x0000000000000a64 <+4>:	mov    QWORD PTR [rbp-0x18],rdi     
0x0000000000000a68 <+8>:	mov    DWORD PTR [rbp-0x4],0x0
0x0000000000000a6f <+15>:	jmp    0xac7 <check_pw+103>
0x0000000000000a71 <+17>:	mov    eax,DWORD PTR [rbp-0x4]
0x0000000000000a74 <+20>:	movsxd rdx,eax
0x0000000000000a77 <+23>:	mov    rax,QWORD PTR [rbp-0x18]
0x0000000000000a7b <+27>:	add    rax,rdx
0x0000000000000a7e <+30>:	movzx  edx,BYTE PTR [rax]
0x0000000000000a81 <+33>:	mov    eax,DWORD PTR [rbp-0x4]
0x0000000000000a84 <+36>:	cdqe   
0x0000000000000a86 <+38>:	lea    rcx,[rax*8+0x0]
0x0000000000000a8e <+46>:	lea    rax,[rip+0x200e4b]        # 0x2018e0 <ws>
0x0000000000000a95 <+53>:	mov    rcx,QWORD PTR [rcx+rax*1]
0x0000000000000a99 <+57>:	mov    eax,DWORD PTR [rbp-0x4]
0x0000000000000a9c <+60>:	cdqe   
0x0000000000000a9e <+62>:	lea    rsi,[rax*4+0x0]
0x0000000000000aa6 <+70>:	lea    rax,[rip+0x200db3]        # 0x201860 <is>
0x0000000000000aad <+77>:	mov    eax,DWORD PTR [rsi+rax*1]
0x0000000000000ab0 <+80>:	cdqe   
0x0000000000000ab2 <+82>:	add    rax,rcx
0x0000000000000ab5 <+85>:	movzx  eax,BYTE PTR [rax]
0x0000000000000ab8 <+88>:	cmp    dl,al
0x0000000000000aba <+90>:	je     0xac3 <check_pw+99>
0x0000000000000abc <+92>:	mov    eax,0x0
0x0000000000000ac1 <+97>:	jmp    0xad2 <check_pw+114>
0x0000000000000ac3 <+99>:	add    DWORD PTR [rbp-0x4],0x1
0x0000000000000ac7 <+103>:	cmp    DWORD PTR [rbp-0x4],0x1f 
0x0000000000000acb <+107>:	jle    0xa71 <check_pw+17>
0x0000000000000acd <+109>:	mov    eax,0x1
0x0000000000000ad2 <+114>:	pop    rbp
0x0000000000000ad3 <+115>:	ret    
```

## Getting the token

It looks like the expected password would be the token we want.

We can take advantage of the moment our string is compared to the expected one to get the plain password, character by character.

One way would be to add a breakpoint at **+92** of **check_pw**. This is the way I did this, there may be an easier way.

1. Set a breakpoint at the start of **check_pw**. `b check_pw`
2. Run the program to this point, you will be prompted for a password. `r`
   * Any password should work, we could use a 32 character long password just to be sure
3. Now we should have the absolute memory direction of the **check_pw** instructions. 

These are the instructions we care most about:

```
0x0000555555554ab8 <+88>:	cmp    dl,al
0x0000555555554aba <+90>:	je    0x555555554ac3 <check_pw+99>
```

4. Now, we set a breakpoint in the comparison. `b *0x555555554ab8`
   * I deleted the old break point too. `del 1`
5. Continue to the comparison instruction. `c`
6. Get the value inside **al**. We can also check **dl** to confirm it has our first char.
   * p/c $al => returns us **b**
   * p/c $dl => returns the first character of our string
7. Now we know that the first character is a **b**, so we could restart the program, change the first letter of our password to **b** and repeat until we are done. But there are easier  ways.

What happens if we modify the **je** to be **jne**? 

Then the code would check the next character instead of exiting, until we finish the 32 characters.

How does this look in machine code? The following command shows us:

`disas /r 0x0000555555554aba,+1`

> 0x0000555555554aba <check_pw+90>:	74 07	je     0x555555554ac3 <check_pw+99>

The instructtion we want, has code 0x75 instead of 0x74. How do we set this?

`set {char}0x0000555555554aba=0x75`

Lets confirm we were sucessfull (``disas /r 0x0000555555554aba,+1``):

> 0x0000555555554aba <check_pw+90>:	75 07	jne    0x555555554ac3 <check_pw+99>

8. Now that we have a way to iterate all the characters we want, we can go on. For this I defined a command that would print the values of **al** and **dl** and continue, until next break.
```
def print_val
   p/c $al
   p/c $dl
   c
   end
```
9. Run the command once and then enter to victory! Each enter will give us the next value of $al (along with the one we provided for that position) until all 32 characters are shown

Each time the command is run, the ouput should be something like:

```
$1 = 70 'F'
$2 = 97 'a'
```

10. We gather all 32 characters, join them and get the password. We confirm it works, running the program again with the password and get the ACCESS_GRANTED message.

> Do note that running the program again reverts the changes we did to the jump instruction.

> If you are getting a ACESS_DENIED after changing the **je** to **jne**, you are nailing one of the values by mistake. It may be better to change **je** to **jmp** instead (op. code 0xE9 )